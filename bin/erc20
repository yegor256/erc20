#!/usr/bin/env ruby
# frozen_string_literal: true

# SPDX-FileCopyrightText: Copyright (c) 2025 Yegor Bugayenko
# SPDX-License-Identifier: MIT

$stdout.sync = true

require 'backtrace'
require 'loog'
require 'thor'
require_relative '../lib/erc20'
require_relative '../lib/erc20/erc20'
require_relative '../lib/erc20/wallet'

# Command line interface for ERC20 operations.
#
# This CLI provides commands for managing ERC20 tokens and ETH on Ethereum:
# generating keys, checking balances, and sending payments.
#
# Author:: Yegor Bugayenko (yegor256@gmail.com)
# Copyright:: Copyright (c) 2025 Yegor Bugayenko
# License:: MIT
class Bin < Thor
  def self.exit_on_failure?
    true
  end

  class_option :contract, type: :string, default: ERC20::Wallet::USDT,
    desc: 'Public address of ERC20 contract'
  class_option :chain, type: :numeric, default: 1,
    desc: 'Ethereum chain ID'
  class_option :ssl, type: :boolean, default: true,
    desc: 'Use SSL for HTTP connections'
  class_option :host, type: :string, default: 'eth.llamarpc.com',
    desc: 'Host name of the provider'
  class_option :port, type: :numeric, default: 443,
    desc: 'TCP port of the provider'
  class_option :http_path, type: :string, default: '/',
    desc: 'URL path for the HTTP RPC entry point of the provider'
  class_option :ws_path, type: :string, default: '/',
    desc: 'URL path for the Websockets entry point of the provider'
  class_option :proxy, type: :string,
    desc: 'HTTP/S proxy for all requests, e.g. "localhost:3128"'
  class_option :attempts, type: :numeric, default: 1,
    desc: 'How many times should we try before failing'
  class_option :dry, type: :boolean, default: false,
    desc: "Don't send a real payment, run in a read-only mode"
  class_option :verbose, type: :boolean, default: false,
    desc: 'Print all possible debug messages'

  desc 'version', 'Print version of the tool'
  def version
    log.info(ERC20::VERSION)
  end

  desc 'key', 'Generate a new Ethereum private key (64 hex symbols)'
  def key
    log.info(Eth::Key.new.private_hex.downcase)
  end

  desc 'address KEY', 'Turn private key into a public address (44 hex symbols)'
  def address(pvt)
    log.info(Eth::Key.new(priv: pvt).address.to_s.downcase)
  end

  desc 'price', 'Get current price of one gas unit, in gwei'
  def price
    log.info(wallet.gas_price)
  end

  desc 'balance ADDRESS', 'Get ERC20 balance'
  def balance(address)
    log.debug("Checking ERC20 balance of #{address}")
    tokens = wallet.balance(address)
    log.debug("The balance is #{tokens} ERC20 tokens (#{tokens.to_f / 1_000_000} USDT)")
    log.info(tokens)
  end

  desc 'eth_balance ADDRESS', 'Get ETH balance'
  def eth_balance(address)
    log.debug("Checking ETH balance of #{address}")
    wei = wallet.eth_balance(address)
    log.debug("The balance of #{address} is #{wei} wei (#{format('%0.4f', wei.to_f / 1_000_000_000_000_000_000)} ETH)")
    log.info(wei)
  end

  desc 'pay KEY ADDRESS AMOUNT', 'Send ERC20 payment'
  def pay(pkey, address, amount)
    priv = Eth::Key.new(priv: pkey)
    log.debug("Sending ERC20 tokens from #{priv.address}")
    log.debug("Sending ERC20 tokens to #{address}")
    amount = tokens(amount)
    log.debug("Sending #{amount} ERC20 tokens")
    if wallet.eth_balance(priv.address.to_s).zero?
      log.debug("ETH balance of #{priv.address} is zero, the txn most definitely will be rejected by the server!")
    end
    log.info(wallet.pay(priv.private_hex, address, amount))
  end

  desc 'eth_pay KEY ADDRESS AMOUNT', 'Send ETH payment'
  def eth_pay(pkey, address, amount)
    priv = Eth::Key.new(priv: pkey)
    log.debug("Sending ETH from #{priv.address}")
    log.debug("Sending ETH to #{address}")
    raise "Amount #{amount.inspect} is not valid" unless /^[0-9]+(\.[0-9]+)?(eth|wei|gwei)?$/.match?(amount)
    amount = wei(amount)
    log.debug("Sending #{amount} wei...")
    log.info(wallet.eth_pay(priv.private_hex, address, amount))
  end

  def self.banner(task, namespace = false, subcommand = false)
    "#{basename} #{task.usage}"
  end

  def self.help(shell, subcommand = false)
    shell.say "Usage (#{ERC20::VERSION}): erc20 [options] command [args]"
    shell.say 'Commands are:'
    super
    shell.say "\nRead this: https://github.com/yegor256/erc20"
  end

  private

  def log
    @log ||= options[:verbose] ? Loog::VERBOSE : Loog::REGULAR
  end

  def wallet
    @wallet ||=
      if options[:dry]
        ERC20::FakeWallet.new
      else
        ERC20::Wallet.new(
          contract: options[:contract],
          host: options[:host], port: options[:port].to_i,
          http_path: options[:http_path], ws_path: options[:ws_path],
          ssl: options[:ssl],
          log: log
        )
      end
  end

  def tokens(amount)
    if /^[0-9]+$/.match?(amount)
      amount = amount.to_i
      log.debug("The token amount equals to #{amount} ERC20 tokens (as provided)")
    elsif /^[0-9]+(\.[0-9]+)?usdt$/.match?(amount)
      amount = (amount.gsub(/usdt$/, '').to_f * 1_000_000).to_i
      log.debug("The USDT amount equals to #{amount} ERC20 tokens")
    elsif /^\$[0-9]+(\.[0-9]+)?$/.match?(amount)
      amount = (amount.gsub(/^\$/, '').to_f * 1_000_000).to_i
      log.debug("The dollar amount equals to #{amount} ERC20 tokens")
    else
      raise "Can't understand amount: #{amount.inspect}"
    end
    amount
  end

  def wei(amount)
    if /^[0-9]+$/.match?(amount)
      amount.to_i
    elsif /[0-9]wei$/.match?(amount)
      amount.gsub(/wei$/, '').to_i
    elsif /[0-9]gwei$/.match?(amount)
      (amount.gsub(/gwei$/, '').to_f * 1_000_000_000).to_i
    elsif /[0-9]eth$/.match?(amount)
      (amount.gsub(/eth$/, '').to_f * 1_000_000_000_000_000_000).to_i
    else
      raise "Can't understand amount: #{amount.inspect}"
    end
  end
end

begin
  Bin.start(ARGV)
rescue StandardError => e
  log = ARGV.include?('--verbose') ? Loog::VERBOSE : Loog::REGULAR
  log.debug(Backtrace.new(e))
  log.error(e.message)
  exit(255)
end
